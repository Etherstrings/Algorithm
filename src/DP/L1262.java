package DP;

public class L1262 {
    //一、寻找子问题
    //考虑最后一个数x，最后一个数选还是不选？
    //x%3==0 那就肯定选
    //x%3==1
    //如果选 那就要从在0-n-1中找到S1，S1 % 3==2 ，这样才能保证总和为%3==0
    //如果不选 那就是0-n-1的能%3==0的最大值
    //x%3==2
    //如果选 那就要从在0-n-1中找到S2，S2 % 3==1 ，这样才能保证总和为%3==0
    //如果不选 那就是0-n-1的能%3==0的最大值

    //因此
    //如果不选x--那就是dp[i-1][j]
    //如果选，那就有三种情况 余0 余1 余2
    //左右两边加一起等于3
    //由 S % 3 == (j-x) % 3
    //得到通用公式：dp[i-1][j-x%3+3]+x

    //1262. 可被三整除的最大和
    //给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。
    //
    //
    //
    //示例 1：
    //
    //输入：nums = [3,6,5,1,8]
    //输出：18
    //解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
    //示例 2：
    //
    //输入：nums = [4]
    //输出：0
    //解释：4 不能被 3 整除，所以无法选出数字，返回 0。
    //示例 3：
    //
    //输入：nums = [1,2,3,4,4]
    //输出：12
    //解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
    public static void main(String[] args) {

    }
    public int maxSumDivThree(int[] nums) {
        final int inf = 1 << 30;
        int n=nums.length;
        //j 0 1 2
        int[][] dp=new int[n+1][3];
        dp[0][0]=0;
        dp[0][1]=dp[0][2]=-inf;
        for(int i=1;i<=n;i++){
            int now=nums[i-1];
            for(int j=0;j<3;j++){
                dp[i][j]=Math.max(dp[i-1][(j-now%3+3)%3]+now,dp[i-1][j]);
            }
        }
        return dp[n][0];
    }
}
